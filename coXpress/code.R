# code for "CoXpress: differential co-expression in gene expression data"
# submitted to BMC Bioinformatics, Michael Watson, 20/7/06
# Modified by Katherine Wang

# install packages
# this step can be skipped if packages are already installed

# required for various bits of analysis
# source("http://www.bioconductor.org/biocLite.R") # biocLite has been replaced by BiocManager
#install.packages("BiocManager")
#BiocManager::install("hu6800.db") # formerly hu6800
#BiocManager::install("hgu95av2")
#BiocManager::install("annaffy")
#BiocManager::install("GO")
#BiocManager::install("KEGG")
#BiocManager::install("GOstats")

# only required for show.heatmap function
#install.packages("gtools")
#install.packages("gdata")
#install.packages("gplots")

# required for the split plot
#install.packages("plotrix")

# download and install coXpress from http://coxpress.sf.net first....
library(coXpress) # use coXpress_1.5.tar.gz, not the ZIP. 
# It can be found in the Files section on this site: https://sourceforge.net/projects/coxpress/files/coxpress/R%203.0/
# as stated here https://stackoverflow.com/a/63395926 , if you use the ZIP, R will complain that it was built under an earlier version of R
# because coXpress was last updated in 2013

# the Golub analysis.  Please note that as coXpress uses random resampling
# methods, the results will change slightly each time the process is repeated
data(golub) # this is included in the coXpress package

# cluster on ALL subset
hc.gene <- cluster.gene(golub.df[,1:27], "pearson", "average")

# cut the tree at a correlation of 0.6
g <- cutree(hc.gene, h=0.4)

# run coXpress on the ALL vs AML subsets
# note 10000 iterations are used.  This will take a LONG time.  Reduce to 1000
# if you are impatient
t <- 1000 # I turned this into a variable so it'd be easier to manipulate
cox <- coXpress(golub.df, g, 1:27, 28:38, times=t) 

# table 1
cox[cox$pr.g1 <= .05 & cox$pr.g2 >= 0.05 & cox$N>=7,]

# figure 2
# note the position and values of the labels for the t statistics will
# need to be changed each time coXpress is run

library(plotrix)

# observed data for group 3
g3 <- golub.df[g==3,]
c1 <- cor(t(g3[,1:27]))
c2 <- cor(t(g3[,28:38]))
v1 <- c1[lower.tri(c1)]
v2 <- c2[lower.tri(c2)]

# true random data from the random uniform distribution
tr <- matrix(runif(1292), nrow=34)
c1r <- cor(t(tr[,1:27]))
c2r <- cor(t(tr[,28:38]))
v1r <- c1r[lower.tri(c1r)]
v2r <- c2r[lower.tri(c2r)]

# random data generated by resampling
rs <- golub.df[trunc(runif(34,1,nrow(golub.df)+1)),]
c1s <- cor(t(rs[,1:27]))
c2s <- cor(t(rs[,28:38]))
v1s <- c1s[lower.tri(c1s)]
v2s <- c2s[lower.tri(c2s)]

# create distributions of t statistics by randomly generating 10000 groups
# of size 34, calculating the correlation matrix, and then calculating t
ds1 <- create.dists(golub.df, 1:27, times=t, sizes=34)
ds2 <- create.dists(golub.df, 28:38, times=t, sizes=34)

# run the density function to plot the distribution
dens <- density(ds1[["n34"]], adjust=1.5)
x <- c(dens$x,155.7)
y <- c(dens$y,0)

# plot the graphs
split.screen(c(2,2))
screen(1)
par(ps=8,mar=c(3,2.7,2,1),mgp=c(2,1,0))
plot(density(v1,adjust=1.5), xlim=c(-1,1), ylim=c(0,5), main="A", xlab="correlation", col="blue")
lines(density(v1r,adjust=1.5), col="red")
lines(density(v1s,adjust=1.5), col="green")
text(mean(v1), 4, "t=155.7", col="blue", ps=8)
text(mean(v1r), 2.2, paste("t=", round(t.test(v1r)$statistic,2), sep=""), col="red")
text(mean(v1s), 1.1, paste("t=", round(t.test(v1s)$statistic,2), sep=""), col="green")

screen(2)
par(ps=8,mar=c(3,2.7,2,1),mgp=c(2,1,0))
plot(density(v2,adjust=1.5), xlim=c(-1,1), ylim=c(0,2), main="B", xlab="correlation", col="blue")
lines(density(v2r,adjust=1.5), col="red")
lines(density(v2s,adjust=1.5), col="green")
text(mean(v2), .8, "t=0.18", col="blue")
text(0.4, 1.1, paste("t=", round(t.test(v2r)$statistic,2), sep=""), col="red")
text(mean(v2s), 1.3, paste("t=", round(t.test(v2s)$statistic,2), sep=""), col="green")

screen(3)
par(ps=8,mar=c(3,2.7,2,1),mgp=c(2,1,0))
par(pch=".")
gap.plot(x, y, gap=c(8,154), gap.axis="x", xlab="t", ylab="Density", main="C", type="l", xtics=c(-2,0,2,4,6,155)) # replaced "gap.bounds" with "gap"
lines(xy.coords(c(155.7-146,155.7-146),c(0,.3)), col="red")
par(ps=8)
text(155.7-146, 0.31, "t=155.7", col="red", pos=2, offset=-.4)

screen(4)
par(ps=8,mar=c(3,2.7,2,1),mgp=c(2,1,0))
plot(density(ds2[["n34"]], adjust=1.5), xlab="t", main="D")
lines(xy.coords(c(0.18,0.18),c(0,.35)), col="red")
par(ps=8)
text(0.18,0.35,"t=0.18", col="red", pos=4)

close.screen(all=TRUE)

# figure 3
png(filename="myplot.png", width=700, height=700) 
# Microsoft Copilot suggested that saving the plot to an image file would bypass the "figure margins too large" error
# The file that it writes to seems to be empty, though?

split.screen(c(3,2))
screen(1)
plot.cluster.genes(d=golub.df[g==3,1:27],scale.scale=TRUE, scale.center=TRUE,ylim=c(-4,4),title="Group 3, N=34",xlab="ALL", ylab="Log expression")
text(1,1,"a")
screen(2)
plot.cluster.genes(d=golub.df[g==3,28:38],scale.scale=TRUE, scale.center=TRUE,ylim=c(-4,4),xlab="AML")
screen(3)
plot.cluster.genes(d=golub.df[g==62,1:27],scale.scale=TRUE, scale.center=TRUE,ylim=c(-4,4),title="Group 62, N=7", xlab="ALL", ylab="Log expression")
screen(4)
plot.cluster.genes(d=golub.df[g==62,28:38],scale.scale=TRUE, scale.center=TRUE,ylim=c(-4,4),xlab="AML")
screen(5)
plot.cluster.genes(d=golub.df[g==121,1:27],scale.scale=TRUE, scale.center=TRUE,ylim=c(-4,4),title="Group 121, N=12", xlab="ALL", ylab="Log expression")
screen(6)
plot.cluster.genes(d=golub.df[g==121,28:38],scale.scale=TRUE, scale.center=TRUE,ylim=c(-4,4),xlab="AML")
close.screen(all = TRUE)

# figure 4
x11()
show.cor.matrices(golub.df,g,3,1:27,28:38)
x11()
show.cor.matrices(golub.df,g,62,1:27,28:38)
x11()
show.cor.matrices(golub.df,g,121,1:27,28:38)

# table 2
df <- inspect.group(golub.df,g,62,1:27,28:38,method="single")
df[1:10,]

# table 3
df[12:21,]

# annotate 
library(annaffy)
library(hu6800.db)
library(hgu95av2)
library(GOstats)

Summarise.hyperGTest <- function(probeids, array) {

   ll <- aafLocusLink(probeids, array)
   lltext <- getText(ll)
   
   mf<-hyperGTest(lltext, lib=array,what="MF")
   bp<-hyperGTest(lltext, lib=array,what="BP")
   cc<-hyperGTest(lltext, lib=array,what="CC")
   
   mfdf <- as.data.frame(mf$pvalues)
   mfdf[,2] <- rownames(mfdf)
   colnames(mfdf) <- c("pvalue","GOID")

   bpdf <- as.data.frame(bp$pvalues)
   bpdf[,2] <- rownames(bpdf)
   colnames(bpdf) <- c("pvalue","GOID")

   ccdf <- as.data.frame(cc$pvalues)
   ccdf[,2] <- rownames(ccdf)
   colnames(ccdf) <- c("pvalue","GOID")
   
   for (i in 1:nrow(mfdf)) {
    goid <- mfdf[i,"GOID"]
    mfdf[i,3] <- Term(GOTERM[[goid]])
   }
   
   mfdf[,4] <- rep("MF",nrow(mfdf))
   
   for (i in 1:nrow(bpdf)) {
    goid <- bpdf[i,"GOID"]
    bpdf[i,3] <- Term(GOTERM[[goid]])
   }
   
   bpdf[,4] <- rep("BP",nrow(bpdf))
   
   for (i in 1:nrow(ccdf)) {
    goid <- ccdf[i,"GOID"]
    ccdf[i,3] <- Term(GOTERM[[goid]])
   }
   
   ccdf[,4] <- rep("CC",nrow(ccdf))
   
   rbind(mfdf,bpdf,ccdf)
}

# Golub data
# I can't figure out how to get this to work
probeids <- golub.gnames[g==3,3]
hgCutoff <- 0.001
params <- new("GOHyperGParams", geneIds = probeids, universeGeneIds = golub.gnames, annotation = "hu6800.db", ontology = "CC", conditional = FALSE, testDirection = "over")

g3godf <- summary(hyperGTest(params)) # GOHyperG was replaced by hyperGTest
write.table(g3godf, "g3godf.txt", sep="\t", row.names=FALSE, col.names=TRUE)

probeids <- golub.gnames[g==62,3]
g62godf <- Summarise.hyperGTest(probeids, "hu6800.db")
write.table(g62godf, "g62godf.txt", sep="\t", row.names=FALSE, col.names=TRUE)

probeids <- golub.gnames[g==121,3]
g121godf <- Summarise.hyperGTest(probeids, "hu6800.db")
write.table(g121godf, "g121godf.txt", sep="\t", row.names=FALSE, col.names=TRUE)

# the ALL subtype analysis
data(COX.ALL)

# cluster data based on BCR subtype
hc.gene <- cluster.gene(ALL[,BCR.idx], "pearson", "average")

# cut the tree at a height of 0.4 (equates to pearson correlation of 0.6)
g <- cutree(hc.gene, h=0.5)

# look at the pairs of genes
cox.p <- cox.pairs(ALL, g, BCR.idx, T.idx)

# find significant and pos in BCR, significant and neg in T
# table 2
cox.p[cox.p$r1>0&cox.p$p1<=.05&cox.p$r2<0&cox.p$p2<=.05,]

# annotate them
probeids <- c(as.vector(ALL.gnames[g==14,1]),as.vector(ALL.gnames[g==201,1]),as.vector(ALL.gnames[g==143,1])) 
outpairs <- affyannotate(probeids, "hgu95av2")

# run coXpress on BCR vs T
cox <- coXpress(ALL, g, BCR.idx, T.idx, times=t)

# look at top genes
# table 5
cox[cox$pr.g2>=.05&cox$N>=10,]

# figure 5
split.screen(c(3,2))
screen(1)
plot.cluster.genes(d=ALL[g==47,BCR.idx],scale.scale=TRUE, scale.center=TRUE,ylim=c(-4,4),title="Group 47, N=16",xlab="BCR", ylab="Log expression")
screen(2)
plot.cluster.genes(d=ALL[g==47,T.idx],scale.scale=TRUE, scale.center=TRUE,ylim=c(-4,4),xlab="T")
screen(3)
plot.cluster.genes(d=ALL[g==31,BCR.idx],scale.scale=TRUE, scale.center=TRUE,ylim=c(-4,4),title="Group 31, N=10", xlab="BCR", ylab="Log expression")
screen(4)
plot.cluster.genes(d=ALL[g==31,T.idx],scale.scale=TRUE, scale.center=TRUE,ylim=c(-4,4),xlab="T")
screen(5)
plot.cluster.genes(d=ALL[g==89,BCR.idx],scale.scale=TRUE, scale.center=TRUE,ylim=c(-4,4),title="Group 89, N=13", xlab="BCR", ylab="Log expression")
screen(6)
plot.cluster.genes(d=ALL[g==89,T.idx],scale.scale=TRUE, scale.center=TRUE,ylim=c(-4,4),xlab="T")
close.screen(all = TRUE)

# linked to annotation
probeids <- as.vector(ALL.gnames[g==47,1])
g47godf <- Summarise.hyperGTest(probeids, "hgu95av2")
write.table(g47godf, "g47godf.txt", sep="\t", row.names=FALSE, col.names=TRUE)

probeids <- as.vector(ALL.gnames[g==31,1])
g31godf <- Summarise.hyperGTest(probeids, "hgu95av2")
write.table(g31godf, "g31godf.txt", sep="\t", row.names=FALSE, col.names=TRUE)

probeids <- as.vector(ALL.gnames[g==89,1])
g89godf <- Summarise.hyperGTest(probeids, "hgu95av2")
write.table(g89godf, "g89godf.txt", sep="\t", row.names=FALSE, col.names=TRUE)