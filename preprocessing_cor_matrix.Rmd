---
title: "Preprocessing for correlation matrix"
author: "Katie Wang"
date: "`r Sys.Date()`"
output: html_document
---
```{r}
library(coXpress)
library(tidyverse)
theme_set(theme_classic())

# TODO: import libraries for DiffCoEx as needed

```


# Goals of this notebook: 
* Perform preprocessing of raw data in order to get it in the formats required for DiffCoEx and coXpress
* Get gene modules (the outputs of DiffCoEx and coXpress)
* Select an arbitrary gene of interest that appears in modules defined by both DiffCoEx and coXpress
* Filter the preprocessed input data to just the chosen module
* Generate correlation matrices (or adjacency matrices? The DiffCoEx authors used adjacency matrices) for both

## Preprocessing (can be implemented in Go)
Try this on toy data (i.e. golub.txt, which can be found in the Github repository) before attempting it with a larger dataset.
```{r}
# Our gene identifiers are in row 1, and so we pass 1 to the row.names argument
golub.df <- read.table("golub.txt", sep="\t", header=TRUE, row.names=1)
```

The golub data has 27 ALL cases and 11 AML cases. We will cluster on the 27 ALL cases.  
(Note: ALL = acute lymphoblastic leukemia, AML = acute myeloid leukemia. So these are the two conditions between which the differential coexpression is examined. The goal of this study was to determine the distinction between these two kinds of leukemia. In other datasets, you might compare the control group against the treatment group.)


### For DiffCoEx
For this golub dataset, I'll skip over the data normalization part for the sake of consistency with the coXpress output. If using the Eker rat data like in the DiffCoEx paper, we should probably use normalized data for both methods.

DiffCoEx wants us to separate the input into two dataframes (by condition) and transpose them so that each column (rather than row) corresponds to a gene.
```{r}
datC1 <- t(golub.df[,1:27]) # ALL condition
datC2 <- t(golub.df[,28:38]) # AML condition
```

### For coXpress
We don't separate the data into two dataframes (one for each condition). Instead, we use golub.df (imported earlier) as-is.


## Get gene modules (must be done in R)
### DiffCoEx
```{r}
# TODO: run DiffCoEx to get gene modules
```

### coXpress
Generate hc.gene.
```{r}
# ALL cases are in columns 1-27
hc.gene  <- cluster.gene(golub.df[,1:27],s="pearson",m="average")
```

Cut the tree (hc.gene) at a height of 0.4 (equates to pearson correlation of 0.6). This choice of cut off is user defined and should be in the range 0 < h < 2.  A low value will produce many modules (groups) with few genes in each module; a large value will produce few modules with many genes.
```{r}
g <- cutree(hc.gene, h=0.4)

# make the formatting a bit nicer
g_df <- data.frame(g) |>
  rownames_to_column("gene") # these are the gene markers
  
g_df[order(g_df$g), ] # sorting by module number for easy viewing
```
g contains the gene modules for coXpress. There seem to be modules of size 1; will want to filter these out.


## Investigate for modules that are similar between the two outputs (can probably be implemented in Go)
TODO (plug into ChatGPT): First filter the two gene module dataframes (g for coXpress, and whatever the DiffCoEx gene module output is called) for modules with >=3 genes (an arbitrary cutoff; could shift it higher). Then do a pairwise comparison between modules in the two dataframes, and return a dataframe with the following columns: DiffCoEx, coXpress, GenesShared, GenesDiff, GenesCox. In this dataframe, each row is for a pair of modules that are similar ("homologous") between DiffCoEx and coXpress. The DiffCoEx and coXpress columns each contain the name of their respective homologous module, while GenesShared contains a vector of gene names that appear in both homologous modules, GenesDiff contains a vector of gene names unique to the DiffCoEx module, and GenesCox contains a vector of gene names unique to the coXpress module.

Or do a set difference and turn it into a percentage; could get a visualization out of that

## Filter the data to only include genes in the chosen module for each method (can be implemented in Go)
We expect that the modules generated by the two methods will be different sizes, and will somewhat differ in the genes included.
### DiffCoEx

### coXpress


## Generate correlation and/or adjacency matrices (figure this out later)
Four matrices should be generated. For each of the two methods, we are comparing coexpression between the ALL and AML conditions. (We expect that the module is highly coexpressed in one condition but not the other.)